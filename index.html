<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Bracketology Ranking Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.prod.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --success: #27ae60;
            --warning: #f39c12;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --border: #bdc3c7;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--dark);
            background-color: var(--light);
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1, h2, h3 {
            color: var(--primary);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid var(--secondary);
            padding-bottom: 10px;
        }
        
        .container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 20px;
        }
        
        .file-upload-area {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: border-color 0.3s;
            cursor: pointer;
        }
        
        .file-upload-area:hover {
            border-color: var(--secondary);
        }
        
        .file-upload-area.dragover {
            border-color: var(--secondary);
            background-color: #f8f9fa;
        }
        
        input[type="file"] {
            display: none;
        }
        
        button {
            background-color: var(--secondary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            margin: 5px;
        }
        
        button:hover {
            background-color: #2980b9;
            transform: translateY(-1px);
        }
        
        button.accent {
            background-color: var(--accent);
        }
        
        button.accent:hover {
            background-color: #c0392b;
        }
        
        button.success {
            background-color: var(--success);
        }
        
        button.success:hover {
            background-color: #229954;
        }
        
        .task-choice {
            display: flex;
            justify-content: space-between;
            margin: 40px 0;
            gap: 20px;
        }
        
        .task-button {
            flex: 1;
            padding: 25px;
            font-size: 16px;
            background-color: white;
            color: var(--dark);
            border: 2px solid var(--secondary);
            border-radius: 8px;
            cursor: pointer;
            text-align: left;
            transition: all 0.3s;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
        }
        
        .task-button:hover {
            background-color: white;
            color: var(--dark);
            transform: none;
        }
        
        .task-button:active {
            transform: translateY(-1px);
            border-color: var(--accent);
        }
        
        .task-title {
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 8px;
            color: var(--primary);
        }
        
        .task-details {
            font-size: 13px;
            color: #7f8c8d;
            line-height: 1.4;
            margin-top: 8px;
        }
        
        .task-field {
            margin-bottom: 4px;
            display: flex;
            gap: 8px;
        }
        
        .task-field-label {
            font-weight: 600;
            color: #5a6c7d;
            min-width: fit-content;
        }
        
        .task-field-value {
            color: #2c3e50;
        }
        
        .progress {
            margin: 20px 0;
            background-color: #ddd;
            border-radius: 6px;
            height: 12px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--secondary);
            transition: width 0.3s;
        }
        
        .vs {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            color: var(--accent);
            min-width: 60px;
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .results-table th, .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        .results-table th {
            background-color: var(--secondary);
            color: white;
            font-weight: 600;
        }
        
        .results-table tr:nth-child(even) {
            background-color: #f9f9fa;
        }
        
        .results-table tr:hover {
            background-color: #e8f4f8;
        }
        
        .data-preview {
            max-height: 200px;
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
        }
        
        .data-preview table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .data-preview th,
        .data-preview td {
            padding: 5px;
            border: 1px solid #ddd;
            font-size: 11px;
        }
        
        .data-preview th {
            background-color: #e9ecef;
            font-weight: 600;
        }
        
        .debug-info {
            background: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
            border-radius: 4px;
            font-family: 'Monaco', 'Consolas', monospace;
        }
        
        @media (max-width: 768px) {
            .task-choice {
                flex-direction: column;
            }
            
            .vs {
                margin: 15px 0;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>Task Bracketology Ranking Tool</h1>
        <tournament-manager></tournament-manager>
    </div>
    
    <script>
        const { createApp, ref, computed, onMounted, watch } = Vue;
        
        // Tournament Progress Component
        const TournamentProgress = {
            props: {
                currentRound: Number,
                currentMatchup: Number,
                completedMatches: Number,
                totalMatches: Number,
                tournamentName: String,
                taskCount: Number
            },
            setup(props) {
                const totalRounds = computed(() => {
                    if (!props.taskCount) return 0;
                    let participantCount = props.taskCount;
                    let rounds = 0;
                    while (participantCount > 1) {
                        participantCount = Math.ceil(participantCount / 2);
                        rounds++;
                    }
                    return rounds;
                });
                
                const currentRoundMatches = computed(() => {
                    // Calculate matches for any round based on participants
                    if (!props.taskCount) return 0;
                    
                    let participants = props.taskCount;
                    // Calculate how many participants are left at the current round
                    for (let i = 0; i < props.currentRound; i++) {
                        participants = Math.ceil(participants / 2);
                    }
                    
                    // Number of matches = floor(participants / 2)
                    // The odd participant (if any) gets a bye
                    return Math.floor(participants / 2);
                });
                
                const globalMatchNumber = computed(() => {
                    return props.completedMatches + 1;
                });
                
                const progressPercentage = computed(() => {
                    if (props.totalMatches === 0) return 0;
                    return (props.completedMatches / props.totalMatches) * 100;
                });
                
                const globalProgressPercentage = computed(() => {
                    if (props.totalMatches === 0) return 0;
                    return Math.round((props.completedMatches / props.totalMatches) * 100);
                });
                
                return {
                    totalRounds,
                    currentRoundMatches,
                    globalMatchNumber,
                    progressPercentage,
                    globalProgressPercentage
                };
            },
            template: `
                <div>
                    <h2>Round {{ currentRound + 1 }} of {{ totalRounds }}, Match {{ currentMatchup + 1 }} of {{ currentRoundMatches }} - {{ tournamentName }}</h2>
                    <div class="progress">
                        <div class="progress-bar" :style="{width: progressPercentage + '%'}"></div>
                    </div>
                    <p>Total match {{ globalMatchNumber }} of {{ totalMatches }} ({{ globalProgressPercentage }}%)</p>
                    
                    <div class="debug-info">
                        <strong>Debug:</strong>
                        Tasks: {{ taskCount }} | 
                        Round: {{ currentRound }} | 
                        Matchup: {{ currentMatchup }} | 
                        Total Rounds: {{ totalRounds }} | 
                        Round Matches: {{ currentRoundMatches }} | 
                        Global: {{ globalMatchNumber }}/{{ totalMatches }} ({{ globalProgressPercentage }}%)
                    </div>
                </div>
            `
        };
        
        // Task Matchup Component
        const TaskMatchup = {
            props: {
                task1: Object,
                task2: Object,
                taskNameColumn: String,
                selectedFields: Array
            },
            emits: ['choose-winner'],
            setup(props, { emit }) {
                // Randomly decide which task goes on which side
                const shouldFlip = ref(Math.random() < 0.5);
                
                const leftTask = computed(() => shouldFlip.value ? props.task2 : props.task1);
                const rightTask = computed(() => shouldFlip.value ? props.task1 : props.task2);
                
                function getTaskTitle(task) {
                    if (!task) return 'BYE';
                    return task[props.taskNameColumn] || 'Untitled Task';
                }
                
                function chooseWinner(sideIndex) {
                    // Map the visual choice back to the original task indices
                    let originalIndex;
                    if (shouldFlip.value) {
                        // If flipped: left=task2(index1), right=task1(index0)
                        originalIndex = sideIndex === 0 ? 1 : 0;
                    } else {
                        // If not flipped: left=task1(index0), right=task2(index1) 
                        originalIndex = sideIndex;
                    }
                    emit('choose-winner', originalIndex);
                }
                
                // Re-randomize when tasks change
                watch(() => [props.task1, props.task2], () => {
                    shouldFlip.value = Math.random() < 0.5;
                });
                
                return {
                    leftTask,
                    rightTask,
                    getTaskTitle,
                    chooseWinner
                };
            },
            template: `
                <div class="task-choice">
                    <button class="task-button" @click="chooseWinner(0)" :disabled="!leftTask">
                        <div class="task-title">{{ getTaskTitle(leftTask) }}</div>
                        <div class="task-details">
                            <div v-for="field in selectedFields" :key="field" class="task-field">
                                <span class="task-field-label">{{ field }}:</span>
                                <span class="task-field-value">{{ leftTask ? (leftTask[field] || 'N/A') : 'No data' }}</span>
                            </div>
                            <div v-if="selectedFields.length === 0" style="color: #bdc3c7; font-style: italic;">
                                No additional fields selected
                            </div>
                        </div>
                    </button>
                    <div class="vs">VS</div>
                    <button class="task-button" @click="chooseWinner(1)" :disabled="!rightTask">
                        <div class="task-title">{{ getTaskTitle(rightTask) }}</div>
                        <div class="task-details">
                            <div v-for="field in selectedFields" :key="field" class="task-field">
                                <span class="task-field-label">{{ field }}:</span>
                                <span class="task-field-value">{{ rightTask ? (rightTask[field] || 'N/A') : 'No data' }}</span>
                            </div>
                            <div v-if="selectedFields.length === 0" style="color: #bdc3c7; font-style: italic;">
                                No additional fields selected
                            </div>
                        </div>
                    </button>
                </div>
            `
        };
        
        // Main Tournament Manager Component
        const TournamentManager = {
            components: {
                TournamentProgress,
                TaskMatchup
            },
            setup() {
                // State
                const currentPhase = ref('setup');
                const csvData = ref([]);
                const csvHeaders = ref([]);
                const taskNameColumn = ref('');
                const selectedSecondaryFields = ref([]);
                const seedingMethod = ref('order');
                const tournamentName = ref('');
                const tasks = ref([]);
                const bracket = ref([]);
                const currentRound = ref(0);
                const currentMatchup = ref(0);
                const completedMatches = ref(0);
                const totalMatches = ref(0);
                const isDragOver = ref(false);
                
                // Computed
                const availableSecondaryFields = computed(() => {
                    return csvHeaders.value.filter(header => header !== taskNameColumn.value);
                });
                
                const currentPair = computed(() => {
                    if (bracket.value.length === 0 || 
                        currentRound.value >= bracket.value.length || 
                        currentMatchup.value >= bracket.value[currentRound.value].length) {
                        return [null, null];
                    }
                    
                    return bracket.value[currentRound.value][currentMatchup.value].teams;
                });
                
                const finalRankings = computed(() => {
                    if (currentPhase.value !== 'results') return [];
                    
                    const rankings = [];
                    
                    // We need to traverse the bracket to determine elimination order
                    // For now, let's create a simple ranking based on when tasks were eliminated
                    // This would need to be enhanced to properly track elimination rounds
                    
                    // Winner is the last remaining task
                    if (bracket.value.length > 0) {
                        const finalRound = bracket.value[bracket.value.length - 1];
                        if (finalRound.length > 0 && finalRound[0].winner) {
                            rankings.push(finalRound[0].winner);
                            
                            // Runner-up is the other finalist
                            const finalist1 = finalRound[0].teams[0];
                            const finalist2 = finalRound[0].teams[1];
                            const runnerUp = finalist1 === finalRound[0].winner ? finalist2 : finalist1;
                            if (runnerUp) rankings.push(runnerUp);
                        }
                    }
                    
                    // For now, add remaining tasks in their original order
                    // This is a simplified version - a complete implementation would track elimination order
                    const remainingTasks = tasks.value.filter(task => !rankings.includes(task));
                    rankings.push(...remainingTasks);
                    
                    return rankings;
                });
                
                // Methods
                function handleFileUpload(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    if (!file.name.toLowerCase().endsWith('.csv')) {
                        alert('Please upload a CSV file.');
                        return;
                    }
                    
                    Papa.parse(file, {
                        header: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            csvData.value = results.data;
                            csvHeaders.value = results.meta.fields || Object.keys(results.data[0] || {});
                            
                            // Auto-select task name column
                            const nameColumns = ['name', 'title', 'task', 'summary', 'Name', 'Title', 'Task', 'Summary'];
                            const foundColumn = csvHeaders.value.find(header => 
                                nameColumns.some(col => header.toLowerCase().includes(col.toLowerCase()))
                            );
                            if (foundColumn) {
                                taskNameColumn.value = foundColumn;
                            } else if (csvHeaders.value.length > 0) {
                                taskNameColumn.value = csvHeaders.value[0];
                            }
                            
                            // Auto-select secondary fields
                            const commonFields = ['Assignee', 'Status', 'Product area', 'Sprint', 'Priority', 'Due Date'];
                            const autoSelectedFields = csvHeaders.value.filter(header => 
                                header !== taskNameColumn.value && 
                                commonFields.some(common => header.toLowerCase().includes(common.toLowerCase()))
                            );
                            selectedSecondaryFields.value = autoSelectedFields.slice(0, 4);
                            
                            // Generate default tournament name
                            tournamentName.value = `Task Ranking ${new Date().toLocaleDateString()}`;
                        },
                        error: function(error) {
                            alert('Error parsing CSV file: ' + error.message);
                        }
                    });
                }
                
                function calculateTotalMatches() {
                    const taskCount = csvData.value.length;
                    return taskCount > 0 ? taskCount - 1 : 0;
                }
                
                function startBracketology() {
                    if (!taskNameColumn.value || !tournamentName.value.trim()) {
                        alert('Please select a task name column and enter a tournament name.');
                        return;
                    }
                    
                    if (csvData.value.length < 2) {
                        alert('Please upload a CSV with at least 2 tasks to compare.');
                        return;
                    }
                    
                    // Prepare tasks
                    tasks.value = [...csvData.value];
                    
                    // Apply seeding
                    if (seedingMethod.value === 'random') {
                        tasks.value = shuffleArray(tasks.value);
                    }
                    
                    // Create the tournament bracket
                    createBracket(tasks.value);
                    
                    // Set counters
                    currentRound.value = 0;
                    currentMatchup.value = 0;
                    completedMatches.value = 0;
                    totalMatches.value = calculateTotalMatches();
                    
                    // Move to matchup phase
                    currentPhase.value = 'matchups';
                }
                
                function createBracket(tasksList) {
                    console.log('Creating bracket with', tasksList.length, 'tasks');
                    bracket.value = [];
                    
                    // Calculate bracket size (power of 2)
                    const participantCount = tasksList.length;
                    let bracketSize = 1;
                    while (bracketSize < participantCount) {
                        bracketSize *= 2;
                    }
                    
                    // Create first round
                    const firstRound = [];
                    let remainingTasks = [...tasksList];
                    
                    for (let i = 0; i < bracketSize / 2; i++) {
                        const team1 = remainingTasks.shift() || null;
                        const team2 = remainingTasks.shift() || null;
                        
                        firstRound.push({
                            teams: [team1, team2],
                            winner: null
                        });
                    }
                    
                    bracket.value.push(firstRound);
                    
                    // Create subsequent rounds
                    let matchesInRound = bracketSize / 4;
                    while (matchesInRound >= 1) {
                        const round = [];
                        for (let i = 0; i < matchesInRound; i++) {
                            round.push({
                                teams: [null, null],
                                winner: null
                            });
                        }
                        bracket.value.push(round);
                        matchesInRound /= 2;
                    }
                    
                    console.log('Bracket created with', bracket.value.length, 'rounds');
                }
                
                function chooseWinner(winnerIndex) {
                    const match = bracket.value[currentRound.value][currentMatchup.value];
                    const winner = match.teams[winnerIndex];
                    
                    // Record the winner
                    match.winner = winner;
                    
                    // Advance winner to next round
                    advanceWinner(winner);
                    
                    // Move to next match
                    completedMatches.value++;
                    moveToNextMatch();
                }
                
                function advanceWinner(winner) {
                    if (currentRound.value >= bracket.value.length - 1) return;
                    
                    const nextRoundMatchIndex = Math.floor(currentMatchup.value / 2);
                    const nextRoundTeamIndex = currentMatchup.value % 2;
                    
                    bracket.value[currentRound.value + 1][nextRoundMatchIndex].teams[nextRoundTeamIndex] = winner;
                }
                
                function moveToNextMatch() {
                    currentMatchup.value++;
                    
                    if (currentMatchup.value >= bracket.value[currentRound.value].length) {
                        currentRound.value++;
                        currentMatchup.value = 0;
                        
                        if (currentRound.value >= bracket.value.length) {
                            currentPhase.value = 'results';
                            return;
                        }
                    }
                    
                    // Skip matches with byes (but don't count them as completed matches)
                    const currentMatch = bracket.value[currentRound.value][currentMatchup.value];
                    if (!currentMatch.teams[0] || !currentMatch.teams[1]) {
                        currentMatch.winner = currentMatch.teams[0] || currentMatch.teams[1];
                        advanceWinner(currentMatch.winner);
                        // Don't increment completedMatches for byes - they're not real matches
                        moveToNextMatch();
                    }
                }
                
                function getTaskTitle(task) {
                    if (!task) return 'Untitled Task';
                    return task[taskNameColumn.value] || 'Untitled Task';
                }
                
                function exportResults() {
                    console.log('Export button clicked');
                    console.log('Final rankings length:', finalRankings.value.length);
                    
                    if (finalRankings.value.length === 0) {
                        console.log('No rankings to export');
                        return;
                    }
                    
                    try {
                        // Create CSV content with rankings
                        const csvContent = [];
                        const headers = ['Rank', 'Task', ...csvHeaders.value];
                        console.log('CSV headers:', headers);
                        csvContent.push(headers.join(','));
                        
                        finalRankings.value.forEach((task, index) => {
                            const row = [index + 1, `"${getTaskTitle(task)}"`];
                            csvHeaders.value.forEach(header => {
                                const value = task[header] || '';
                                row.push(`"${String(value).replace(/"/g, '""')}"`);
                            });
                            csvContent.push(row.join(','));
                        });
                        
                        console.log('CSV content created, rows:', csvContent.length);
                        
                        // Create the CSV string
                        const csvString = csvContent.join('\n');
                        const filename = `${tournamentName.value.replace(/[^a-z0-9]/gi, '_')}_rankings.csv`;
                        
                        // Try multiple download methods
                        
                        // Method 1: Direct data URL
                        try {
                            const dataUrl = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csvString);
                            const a = document.createElement('a');
                            a.href = dataUrl;
                            a.download = filename;
                            a.style.display = 'none';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            console.log('Method 1 (data URL) attempted');
                        } catch (e) {
                            console.log('Method 1 failed:', e);
                        }
                        
                        // Method 2: Show CSV in new window as fallback
                        setTimeout(() => {
                            try {
                                const newWindow = window.open();
                                if (newWindow) {
                                    newWindow.document.write('<pre>' + csvString + '</pre>');
                                    newWindow.document.title = filename;
                                    console.log('Method 2 (new window) attempted');
                                } else {
                                    // Method 3: Copy to clipboard as last resort
                                    if (navigator.clipboard) {
                                        navigator.clipboard.writeText(csvString).then(() => {
                                            alert('CSV data copied to clipboard! You can paste it into a text file and save as .csv');
                                        });
                                        console.log('Method 3 (clipboard) attempted');
                                    } else {
                                        // Method 4: Show in alert as final fallback
                                        alert('Download blocked. Here is your CSV data:\n\n' + csvString.substring(0, 500) + '...\n\n(truncated)');
                                        console.log('Method 4 (alert) attempted');
                                    }
                                }
                            } catch (e) {
                                console.log('Fallback methods failed:', e);
                                alert('Unable to download or display CSV. Check console for data.');
                                console.log('Full CSV data:', csvString);
                            }
                        }, 100);
                        
                        console.log('Export process completed');
                    } catch (error) {
                        console.error('Error exporting CSV:', error);
                        alert('Error exporting CSV: ' + error.message);
                    }
                }
                
                function shuffleArray(array) {
                    const newArray = [...array];
                    for (let i = newArray.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                    }
                    return newArray;
                }
                
                function restartBracketology() {
                    if (confirm('Are you sure you want to start over?')) {
                        currentPhase.value = 'setup';
                        csvData.value = [];
                        csvHeaders.value = [];
                        taskNameColumn.value = '';
                        selectedSecondaryFields.value = [];
                        tournamentName.value = '';
                        tasks.value = [];
                        bracket.value = [];
                        currentRound.value = 0;
                        currentMatchup.value = 0;
                        completedMatches.value = 0;
                        totalMatches.value = 0;
                        seedingMethod.value = 'order';
                    }
                }
                
                return {
                    currentPhase,
                    csvData,
                    csvHeaders,
                    taskNameColumn,
                    selectedSecondaryFields,
                    availableSecondaryFields,
                    seedingMethod,
                    tournamentName,
                    tasks,
                    currentRound,
                    currentMatchup,
                    completedMatches,
                    totalMatches,
                    currentPair,
                    finalRankings,
                    isDragOver,
                    handleFileUpload,
                    calculateTotalMatches,
                    startBracketology,
                    chooseWinner,
                    exportResults,
                    getTaskTitle,
                    restartBracketology
                };
            },
            template: `
                <!-- Setup Phase -->
                <div class="container" v-if="currentPhase === 'setup'">
                    <h2>Load Your Tasks</h2>
                    
                    <!-- File Upload -->
                    <div class="file-upload-area" @click="$refs.fileInput.click()">
                        <div style="font-size: 16px; margin-bottom: 10px;">
                            <strong>Click to upload</strong> or drag and drop your CSV file here
                        </div>
                        <div style="color: #7f8c8d; font-size: 14px;">
                            CSV files with tasks exported from Asana, Linear, or any project management tool
                        </div>
                    </div>
                    <input type="file" ref="fileInput" @change="handleFileUpload" accept=".csv">
                    
                    <!-- Data Preview -->
                    <div v-if="csvData.length > 0">
                        <h3>Data Preview ({{ csvData.length }} tasks loaded)</h3>
                        <div class="data-preview">
                            <table>
                                <thead>
                                    <tr>
                                        <th v-for="header in csvHeaders" :key="header">{{ header }}</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="(row, index) in csvData.slice(0, 5)" :key="index">
                                        <td v-for="header in csvHeaders" :key="header">
                                            {{ row[header] || '-' }}
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                            <div v-if="csvData.length > 5" style="text-align: center; margin-top: 10px; color: #7f8c8d;">
                                ... and {{ csvData.length - 5 }} more tasks
                            </div>
                        </div>
                        
                        <!-- Column Selection -->
                        <div style="margin: 20px 0;">
                            <h4>Select Task Name Column:</h4>
                            <select v-model="taskNameColumn" style="padding: 8px;">
                                <option v-for="header in csvHeaders" :key="header" :value="header">{{ header }}</option>
                            </select>
                        </div>
                        
                        <!-- Secondary Fields Selection -->
                        <div style="margin: 20px 0;">
                            <h4>Select Additional Fields to Display:</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 10px;">
                                <label v-for="header in availableSecondaryFields" :key="header" style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" v-model="selectedSecondaryFields" :value="header">
                                    <span>{{ header }}</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Seeding Options -->
                        <div style="margin: 20px 0; padding: 20px; background-color: #f8f9fa; border-radius: 6px;">
                            <h4>Choose Seeding Method:</h4>
                            <div style="display: flex; gap: 20px; margin-top: 10px;">
                                <label style="display: flex; align-items: center; gap: 8px;">
                                    <input type="radio" v-model="seedingMethod" value="order">
                                    <span>Use file order (first task = #1 seed)</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px;">
                                    <input type="radio" v-model="seedingMethod" value="random">
                                    <span>Random seeding</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Tournament Name -->
                        <div style="margin: 20px 0;">
                            <label><strong>Tournament Name:</strong></label>
                            <input type="text" v-model="tournamentName" 
                                   style="width: 100%; padding: 10px; margin-top: 5px; border: 1px solid #ddd; border-radius: 4px;"
                                   placeholder="Enter a name for this ranking session">
                        </div>
                        
                        <p><strong>Total matches needed:</strong> {{ calculateTotalMatches() }}</p>
                        <button @click="startBracketology" :disabled="!taskNameColumn || !tournamentName.trim()">Start Task Ranking</button>
                    </div>
                </div>
                
                <!-- Matchup Phase -->
                <div class="container" v-if="currentPhase === 'matchups'">
                    <tournament-progress 
                        :current-round="currentRound"
                        :current-matchup="currentMatchup"
                        :completed-matches="completedMatches"
                        :total-matches="totalMatches"
                        :tournament-name="tournamentName"
                        :task-count="tasks.length"
                    />
                    
                    <task-matchup 
                        :task1="currentPair[0]"
                        :task2="currentPair[1]"
                        :task-name-column="taskNameColumn"
                        :selected-fields="selectedSecondaryFields"
                        @choose-winner="chooseWinner"
                    />
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <button @click="restartBracketology" class="accent">Start Over</button>
                    </div>
                </div>
                
                <!-- Results Phase -->
                <div class="container" v-if="currentPhase === 'results'">
                    <h2>Your Task Rankings - {{ tournamentName }}</h2>
                    <p>Based on your choices, here are your tasks ranked from highest to lowest priority:</p>
                    
                    <div class="results-table-container">
                        <table class="results-table">
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Task</th>
                                    <th v-for="field in selectedSecondaryFields" :key="field">{{ field }}</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="(task, index) in finalRankings" :key="index">
                                    <td><strong>{{ index + 1 }}</strong></td>
                                    <td>{{ getTaskTitle(task) }}</td>
                                    <td v-for="field in selectedSecondaryFields" :key="field">
                                        {{ task[field] || '-' }}
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <div style="text-align: center; margin-top: 30px;">
                        <button @click="exportResults" class="success" style="margin-right: 10px;">
                            📥 Download Rankings CSV
                        </button>
                        <button @click="restartBracketology" class="accent">Start Over</button>
                    </div>
                </div>
            `
        };
        
        // Create the main app
        createApp({
            components: {
                TournamentManager
            }
        }).mount('#app');
    </script>
</body>
</html>
                    